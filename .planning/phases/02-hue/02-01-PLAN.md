---
phase: 02-hue
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - gohexdump/internal/hue/hue.go
  - gohexdump/cmd/hexboard/main.go
  - gohexdump/go.mod
  - gohexdump/go.sum
autonomous: false
requirements: [HUE-01, HUE-02, HUE-03, HUE-04]

must_haves:
  truths:
    - "Sending a message via the web form turns on the Hue-connected light within a few seconds"
    - "A Hue failure (bridge unreachable, bad key) does not delay the message from displaying"
    - "If /var/lib/hexboard/hue.toml is absent, the service starts normally with Hue silently disabled"
    - "If hue.toml is present but incomplete, the service logs the error and starts with Hue disabled"
  artifacts:
    - path: "gohexdump/internal/hue/hue.go"
      provides: "Config struct, LoadConfig(), TurnOn() — the complete Hue package"
      exports: [Config, LoadConfig, TurnOn]
    - path: "gohexdump/cmd/hexboard/main.go"
      provides: "Hue config loaded at startup; hueConf field on display; goroutine fired in showMessage"
      contains: "hue.LoadConfig"
    - path: "gohexdump/go.mod"
      provides: "BurntSushi/toml v1.3.2 dependency"
      contains: "BurntSushi/toml"
  key_links:
    - from: "gohexdump/cmd/hexboard/main.go showMessage()"
      to: "internal/hue.Config.TurnOn()"
      via: "go d.hueConf.TurnOn() goroutine"
      pattern: "go d\\.hueConf\\.TurnOn\\(\\)"
    - from: "gohexdump/cmd/hexboard/main.go main()"
      to: "internal/hue.LoadConfig()"
      via: "startup config load"
      pattern: "hue\\.LoadConfig"
    - from: "internal/hue/hue.go TurnOn()"
      to: "Hue bridge HTTP API"
      via: "hueClient PUT with 5s timeout"
      pattern: "hueClient\\.Do"
---

<objective>
Add Philips Hue light-on automation to hexboard: whenever any message is sent to the display
(via web form or TCP), a fire-and-forget goroutine turns on the configured Hue light.
Configuration is a TOML file at /var/lib/hexboard/hue.toml; absent or incomplete config
silently disables the feature.

Purpose: Sending a message to the display also illuminates the room — the display light turns on
automatically so the message is visible.

Output: New internal/hue package; updated main.go with hueConf field on display struct and
goroutine trigger in showMessage(); BurntSushi/toml dependency added; deployed and verified
on Pi Zero.
</objective>

<execution_context>
@/Users/richard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-hue/02-CONTEXT.md
@.planning/phases/02-hue/02-RESEARCH.md

<interfaces>
<!-- Key existing code the executor needs. No codebase exploration required. -->

From gohexdump/cmd/hexboard/main.go:
```go
// display struct — add hueConf field:
type display struct {
    rain   screen.Screen
    ripple screen.Screen
    text   screen.TextScreen
    cursor screen.Cursor
    // ADD: hueConf *hue.Config   // nil when Hue is disabled
}

// showMessage — add goroutine trigger after screenChan <- d.ripple:
func (d *display) showMessage(msg string, screenChan chan<- screen.Screen, timeout time.Duration) {
    d.text.Clear()
    for row, line := range strings.SplitN(strings.ToUpper(msg), "\n", 4) {
        runes := []rune(line)
        if len(runes) > 32 {
            runes = runes[:32]
        }
        d.text.WriteAt(string(runes), 0, row)
    }
    screenChan <- d.ripple
    // ADD: if d.hueConf != nil { go d.hueConf.TurnOn() }
    go func() {
        time.Sleep(timeout)
        screenChan <- d.rain
    }()
}

// main() — load hue config after store.OpenDB():
//   hueCfg, err := hue.LoadConfig()
//   if err != nil { log and continue with nil hueCfg }
//   d := newDisplay()
//   d.hueConf = hueCfg
```

From gohexdump/internal/store/store.go (pattern reference):
```go
const dbPath = "/var/lib/hexboard/hexboard.db"  // analogous: configPath in hue.go

func OpenDB() (*sql.DB, error) { ... }           // analogous: LoadConfig() returns (*Config, error)
// fail-soft: caller logs err, continues with nil
```

From gohexdump/go.mod:
```
module post6.net/gohexdump
go 1.13
require (
    github.com/jacobsa/go-serial ...
    github.com/mattn/go-sqlite3 v1.14.34 ...
    golang.org/x/term v0.5.0
)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create internal/hue package and add BurntSushi/toml dependency</name>
  <files>gohexdump/internal/hue/hue.go, gohexdump/go.mod, gohexdump/go.sum</files>
  <action>
Create gohexdump/internal/hue/hue.go with the complete Hue package. Then run go get locally
to add the BurntSushi/toml dependency.

**hue.go contents:**

```go
// Package hue provides Philips Hue bridge integration for hexboard.
// It reads a TOML config at /var/lib/hexboard/hue.toml and exposes
// a TurnOn() method that fires a non-blocking PUT to the Hue v1 CLIP API.
package hue

import (
    "bytes"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "os"
    "strings"
    "time"

    "github.com/BurntSushi/toml"
)

const configPath = "/var/lib/hexboard/hue.toml"

// Config holds the Hue connection parameters read from hue.toml.
// All three fields must be non-empty for Hue to be active.
type Config struct {
    BridgeIP string `toml:"bridge_ip"`
    APIKey   string `toml:"api_key"`
    DeviceID string `toml:"device_id"`
}

// LoadConfig reads /var/lib/hexboard/hue.toml.
// Returns (nil, nil) if the file is absent — Hue is silently disabled.
// Returns (nil, err) if the file exists but is malformed or incomplete.
// The caller should log the error and continue with Hue disabled.
func LoadConfig() (*Config, error) {
    var cfg Config
    _, err := toml.DecodeFile(configPath, &cfg)
    if err != nil {
        if os.IsNotExist(err) {
            return nil, nil  // absent is not an error — just disabled
        }
        return nil, err
    }
    if cfg.BridgeIP == "" || cfg.APIKey == "" || cfg.DeviceID == "" {
        return nil, fmt.Errorf("hue.toml: bridge_ip, api_key, and device_id are all required")
    }
    return &cfg, nil
}

// hueClient has a 5-second timeout to prevent goroutine leak when bridge is unreachable.
var hueClient = &http.Client{Timeout: 5 * time.Second}

// TurnOn sends a PUT to the Hue bridge to turn the configured light on.
// Designed to be called as: go cfg.TurnOn()
// Logs and returns silently on any error — never blocks the caller.
func (c *Config) TurnOn() {
    body, err := json.Marshal(map[string]bool{"on": true})
    if err != nil {
        log.Printf("hue: marshal: %v", err)
        return
    }
    bridgeIP := strings.TrimRight(c.BridgeIP, "/")
    url := fmt.Sprintf("http://%s/api/%s/lights/%s/state", bridgeIP, c.APIKey, c.DeviceID)
    req, err := http.NewRequest(http.MethodPut, url, bytes.NewReader(body))
    if err != nil {
        log.Printf("hue: request: %v", err)
        return
    }
    req.Header.Set("Content-Type", "application/json")
    resp, err := hueClient.Do(req)
    if err != nil {
        log.Printf("hue: put: %v", err)
        return
    }
    resp.Body.Close()
}
```

**Add dependency** (run from gohexdump/ directory locally — rsync will sync go.mod and go.sum to device):
```bash
cd /Users/richard/dev/hexboard/gohexdump && go get github.com/BurntSushi/toml@v1.3.2
```

Note: go.sum will be generated automatically by go get. The module is added locally; the actual
build happens on the Pi via make deploy. The device's Go 1.19 satisfies BurntSushi/toml's go 1.16 minimum.
  </action>
  <verify>
    <automated>cd /Users/richard/dev/hexboard/gohexdump && grep "BurntSushi/toml" go.mod && ls internal/hue/hue.go && echo "OK"</automated>
  </verify>
  <done>
    - gohexdump/internal/hue/hue.go exists with Config struct, LoadConfig(), TurnOn()
    - go.mod contains github.com/BurntSushi/toml v1.3.2
    - go.sum updated by go get
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire hue into main.go display struct and showMessage</name>
  <files>gohexdump/cmd/hexboard/main.go</files>
  <action>
Make three targeted edits to main.go:

**Edit 1 — Add hueConf field to display struct:**
```go
type display struct {
    rain    screen.Screen
    ripple  screen.Screen
    text    screen.TextScreen
    cursor  screen.Cursor
    hueConf *hue.Config   // nil when Hue is disabled
}
```

**Edit 2 — Fire goroutine in showMessage after screenChan <- d.ripple:**
```go
func (d *display) showMessage(msg string, screenChan chan<- screen.Screen, timeout time.Duration) {
    d.text.Clear()
    for row, line := range strings.SplitN(strings.ToUpper(msg), "\n", 4) {
        runes := []rune(line)
        if len(runes) > 32 {
            runes = runes[:32]
        }
        d.text.WriteAt(string(runes), 0, row)
    }
    screenChan <- d.ripple
    if d.hueConf != nil {
        go d.hueConf.TurnOn()
    }
    go func() {
        time.Sleep(timeout)
        screenChan <- d.rain
    }()
}
```

**Edit 3 — Load Hue config in main() after store.OpenDB, before newDisplay():**
```go
hueCfg, err := hue.LoadConfig()
if err != nil {
    log.Printf("hue: config error: %v — Hue disabled", err)
    hueCfg = nil
}
if hueCfg != nil {
    log.Printf("hue: enabled (bridge=%s device=%s)", hueCfg.BridgeIP, hueCfg.DeviceID)
} else {
    log.Printf("hue: disabled (no config or config error)")
}

d := newDisplay()
d.hueConf = hueCfg
d.cursor.SetCursor(0, 0)
```

Also add the import for the hue package at the top:
```go
"post6.net/gohexdump/internal/hue"
```

Note on nil handling: LoadConfig returns (nil, nil) when file is absent — this is intentional.
The nil check on err covers malformed-file case; nil hueCfg is safe since showMessage checks
`d.hueConf != nil` before calling TurnOn(). This satisfies HUE-04.

Do NOT add any web UI feedback for Hue status — that is v2 (out of scope per CONTEXT.md).
  </action>
  <verify>
    <automated>cd /Users/richard/dev/hexboard/gohexdump && grep -n "hueConf" cmd/hexboard/main.go && grep -n "hue.LoadConfig" cmd/hexboard/main.go && grep -n "go d.hueConf.TurnOn" cmd/hexboard/main.go && echo "OK"</automated>
  </verify>
  <done>
    - display struct has hueConf *hue.Config field
    - showMessage fires go d.hueConf.TurnOn() after pushing ripple screen
    - main() loads hue config with LoadConfig(), logs result, sets d.hueConf
    - hue package imported in main.go
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Deploy to Pi and verify Hue integration</name>
  <action>
Deploy the updated binary to the Pi Zero. BurntSushi/toml is pure Go (no CGo), so the
incremental build is fast (~2 minutes vs ~24 min for the initial sqlite3 CGo compilation).

```bash
cd /Users/richard/dev/hexboard/gohexdump && make deploy
```

After deploy, run the verification steps described in how-to-verify.
  </action>
  <what-built>
    Complete Phase 2 Hue integration: internal/hue package (Config, LoadConfig, TurnOn),
    wired into display struct and showMessage, deployed to Pi Zero via make deploy.
  </what-built>
  <how-to-verify>
    **Test 1 — Hue disabled (no config file):**
    1. Confirm /var/lib/hexboard/hue.toml does not exist on device (or remove it)
    2. Restart service: ssh txt sudo systemctl restart hexboard
    3. Check logs: ssh txt sudo journalctl -u hexboard -n 10
    4. Expected log line: "hue: disabled (no config or config error)"
    5. Send a message: echo "test" | nc txt 8080
    6. Expected: message appears on display, no errors in logs

    **Test 2 — Hue enabled with real config (if Hue bridge is available):**
    1. Create config on Pi (substitute real values):
       ssh txt sudo tee /var/lib/hexboard/hue.toml
       bridge_ip = "YOUR_BRIDGE_IP"
       api_key   = "YOUR_API_KEY"
       device_id = "YOUR_DEVICE_ID"
       (Ctrl-D to finish)
    2. Restart service: ssh txt sudo systemctl restart hexboard
    3. Check logs: expected "hue: enabled (bridge=... device=...)"
    4. Send a message: echo "hue test" | nc txt 8080
    5. Expected: light turns on within 5 seconds; message displays simultaneously

    **Test 3 — Hue failure does not block display (HUE-03):**
    1. Set an invalid bridge IP in hue.toml (e.g., bridge_ip = "192.0.2.1")
    2. Restart service
    3. Send a message: echo "block test" | nc txt 8080
    4. Expected: message appears immediately on display (not delayed by 5s timeout)
    5. After ~5s: "hue: put: ..." error appears in journalctl (not before message display)
  </how-to-verify>
  <verify>
    <automated>ssh txt sudo systemctl is-active hexboard</automated>
  </verify>
  <done>Service running after deploy; hue disabled/enabled log line present at startup; messages display without delay regardless of Hue status</done>
  <resume-signal>Type "approved" when verified, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After deploy and checkpoint approval:

```bash
# Service is active
ssh txt sudo systemctl is-active hexboard

# Startup log shows hue status
ssh txt sudo journalctl -u hexboard -n 20 | grep hue

# Message flow: send arrives, display shows it, hue fires (or logs disabled)
echo "verify hue" | nc txt 8080
ssh txt sudo journalctl -u hexboard -n 5
```

Confirm:
- Service running after deploy with new binary
- "hue: disabled" or "hue: enabled" log line at startup
- No crash when hue.toml is absent
- No blocking of message display even when bridge is unreachable
</verification>

<success_criteria>
1. Sending a message triggers Hue light-on (when configured) within 5 seconds
2. Message appears on display immediately, not delayed by Hue call
3. Service starts cleanly with no hue.toml (HUE-04 — silently disabled)
4. Service starts cleanly with malformed hue.toml (HUE-04 — logs error, disables)
5. BurntSushi/toml in go.mod; hue package in gohexdump/internal/hue/
</success_criteria>

<output>
After completion, create `.planning/phases/02-hue/02-01-SUMMARY.md` following the summary template.
Update `.planning/STATE.md` to reflect Phase 2 complete.
Update `.planning/ROADMAP.md` Phase 2 progress to 1/1 complete.
</output>
